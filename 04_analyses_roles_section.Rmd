---
title: "Pocoroch : Analyses niveau role et niveau section"
author: "Anaïs Rey"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  rmdformats::readthedown:
    code_folding: hide
    gallery: yes
    highlight: tango
    lightbox: yes
    thumbnails: no
    toc_depth: 6
    number_sections: true
    css: styles.css # if we want to save the styles in a css and call it inside of having it inside the case as here.
    #https://github.com/juba/rmdformats/blob/master/inst/templates/readthedown/readthedown.css
    #https://stackoverflow.com/questions/42935320/how-to-change-the-color-theme-on-rmdformats-readthedown
editor_options:
  chunk_output_type: console
---

<script>
   $(document).ready(function() {
     $head = $('#header');
     $head.prepend('<img src=\"logo_rmd_pocoroch.png\" style=\"float: right;width: 150px;\"/>')
   });
</script>

  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, eval = TRUE, cache = FALSE)
```

**But du script: **

  + Evaluer l'importance des rôles Haut et Bas pour l'infralittoral et des rôles Côte à côte pour le circalittoral dans la détection de diversité 
  
  + Evaluer l'importance de la longueur du transect dans la détection de diversité

# Load packages {.tabset}
## Plot
```{r}
library(ggplot2)
library(knitr)
library(ggpubr)
```

## Formatting
```{r}
library(dplyr)
library(tidyr)
library(tibble)
library(purrr)
library(stringr)
library(forcats)
library(reshape2)
```

## Ecology 
```{r}
library(vegan)
library(adespatial)
library(ade4)
```

# Import data

```{r}
# data from UVC sampling
# -- not normalized to compare role
load(file="./Data/TR_modified.RData")
load(file="./Data/TC_modified.RData")

# -- normalized at the section level 
load(file = "./Data/TR_agg_sp_troncon.RData")

# rename
TR <- TR.modif
TC <- TC.modif
TR.sec <- TR.agg.sp.troncon

# Trait habitats
habitat <- read.csv2("./Traits/Habitat_Pierre/Taxa_habitat_PT.csv")
```

# Roles

## Modif dataset

```{r}
# --- Transect 
unique(TR$role) # tous les transects ont des rôles

# on vire les roles avec no species
TR.nosp <- TR %>%  filter(nomCite!="No_species") 

# et du coup on vire les transects avec un seul rôle
TR.single <- TR.nosp %>%
  distinct(idSINPRegroupement_tran, idSINPRegroupement_role) %>%
  group_by(idSINPRegroupement_tran) %>%
  tally() %>%
  filter(n<2) %>%
  pull(idSINPRegroupement_tran)

TR.forRole <- TR.nosp %>% 
  filter(!idSINPRegroupement_tran %in% TR.single) %>%
  distinct(nomCite, abondance,
           role, idSINPRegroupement_role,
           idSINPRegroupement_tran, techniqueEchantillonnage_tran) %>%
  group_by(techniqueEchantillonnage_tran, idSINPRegroupement_tran,
           idSINPRegroupement_role, role, nomCite) %>%
  summarize(ab.2=sum(abondance)) %>%
  mutate(tech.tran.2 = techniqueEchantillonnage_tran) %>%
  ungroup() %>%
  mutate(role.2 = case_when(str_detect(role,"B") ~ "B",
                            str_detect(role,"H") ~ "H",
                            role == "C1" ~ "C",
                            role == "C4" ~ "N")) %>%
  as.data.frame() %>%
  select(-techniqueEchantillonnage_tran) %>%
  select(-role) %>%
  rename(role = role.2) %>%
  mutate(protocole = "TR")
    
TR.forRole %>%
  distinct(idSINPRegroupement_tran, idSINPRegroupement_role,
           role, tech.tran.2) %>%
  group_by(role, tech.tran.2) %>%
  tally() %>%
  spread(role, n, fill=0) %>% 
  kable(caption="Protocole Transect : nb de role par tech d'échantillonnage")


# --- Time count
unique(TC$role) # tous les transects n'ont pas un rôle

# on vire les roles avec no species
TC.nosp <- TC %>%  filter(nomCite!="No_species") 

TC.nosp %>%
  distinct(idSINPRegroupement_tran, idSINPRegroupement_role,
           role, techniqueEchantillonnage_tran) %>%
  group_by(role, techniqueEchantillonnage_tran) %>%
  tally() %>%
  spread(role, n, fill=0) 

# on supprime les roles avec no_species et avec NA et les techniques d'éch à problème
TC.tmp <-  TC.nosp %>% 
  # on supprime les cas où le rôle n'est pas rentré (que pour 2018 normalement)
  filter(!is.na(role)) %>%
  # on enlève les combinaisons de rôle qui n'ont pas au moins H et B ou C et N
  # ! vérifier avec Pierre 
  filter(techniqueEchantillonnage_tran!="NN" & 
         techniqueEchantillonnage_tran!="HBCBC" &
         #techniqueEchantillonnage_tran!="BNC" &
         #techniqueEchantillonnage_tran!="CNB" &
         #techniqueEchantillonnage_tran!="CNH" &
         techniqueEchantillonnage_tran!="HBCC") %>%
  filter(role =="C" | role =="N" | role == "H" | role == "B" ) %>%
  # on supprime les rôles non essentiels pour BNC, CNB et CNH
  mutate(to_rm = case_when(techniqueEchantillonnage_tran=="BNC" & role == "B" ~ "to.rm",
                            techniqueEchantillonnage_tran=="CNB" & role == "B" ~ "to.rm",
                            techniqueEchantillonnage_tran=="CNH" & role == "H" ~ "to.rm",
                           TRUE ~ "to.keep")) %>%
  filter(to_rm == "to.keep") %>%
  # on simplifie la tech d'échantillonnage
  mutate(tech.tran.2 = case_when(str_detect(techniqueEchantillonnage_tran, "HB|HHB") ~ "HB",
                                 str_detect(techniqueEchantillonnage_tran,
                                            "CC|CNN|NBCC|CN|CNBC|BNC") ~ "CC")) %>%
  # on sélectionne aléatoirement un plongeur sur 2 
  # qd il y a 3 plongeurs et que 2 ont fait le même rôle
  distinct(tech.tran.2,
           idSINPRegroupement_tran, role, idSINPRegroupement_role) %>%
  group_by(idSINPRegroupement_tran, role) %>%
  sample_n(1) %>%
  ungroup() %>%
  # on recreé le dataframe
  left_join(TC) %>%
  select(-techniqueEchantillonnage_tran)
  
# et du coup on vire les transects avec un seul rôle
TC.single <- TC.tmp %>%
  distinct(idSINPRegroupement_tran, idSINPRegroupement_role) %>%
  group_by(idSINPRegroupement_tran) %>%
  tally() %>%
  filter(n<2) %>%
  pull(idSINPRegroupement_tran)

TC.forRole <- TC.tmp %>% 
  filter(!idSINPRegroupement_tran %in% TC.single) %>%
  left_join(TC) %>%
  distinct(nomCite, abondance,
           role, idSINPRegroupement_role,
           idSINPRegroupement_tran, tech.tran.2) %>%
  group_by(tech.tran.2, idSINPRegroupement_tran,
           idSINPRegroupement_role, role, nomCite) %>%
  summarize(ab.2=sum(abondance)) %>%
  ungroup() %>%
  as.data.frame()  %>%
  mutate(protocole = "TC")

TC.forRole %>%
  distinct(idSINPRegroupement_tran, idSINPRegroupement_role,
           role, tech.tran.2) %>%
  group_by(role, tech.tran.2) %>%
  tally() %>%
  spread(role, n, fill=0) %>% 
  kable(caption="Protocole Temps : nb de role par tech d'échantillonnage")
```


## Diversite alpha par role

Boxplot des indices de diversité

```{r}
# on combine les communautés des 2 protocoles
role.comm <- bind_rows(TC.forRole, TR.forRole) %>%
  select(nomCite, ab.2, idSINPRegroupement_role) %>%
  spread(nomCite, ab.2, fill=0) %>%
  arrange(idSINPRegroupement_role) %>%
  column_to_rownames(var="idSINPRegroupement_role")

# on combine les informations des rôles des 2 protocoles
role.data <- bind_rows(TC.forRole, TR.forRole) %>%
  select(idSINPRegroupement_role, role, tech.tran.2, protocole) %>%
  distinct() %>%
  arrange(idSINPRegroupement_role) 

# Calcule de la richesse (S), de l'indice de Shannon et de l'inverse de l'indice de Simpson pour chaque rôle des 2 protocoles
S <- specnumber(role.comm) %>% as.data.frame() %>% rename(Richesse = ".")
H <- diversity(role.comm, "shannon") %>% as.data.frame() %>% rename(Shannon = ".")
invsimp <- diversity(role.comm, "inv") %>% as.data.frame() %>% rename(Inv.simp = ".")

div.ind <- cbind(S, H, invsimp) %>%
  rownames_to_column(var="idSINPRegroupement_role") %>%
  full_join(role.data) %>%
  gather("indices", "Valeur de l'indice de diversité", -idSINPRegroupement_role, -role, -tech.tran.2, -protocole) %>%
  mutate(tech.tran.2 = gsub("HB", "Haut-Bas", tech.tran.2),
         tech.tran.2 = gsub("CC", "Côte à Côte", tech.tran.2))%>%
  rename(`Rôle` = role)

div.ind$indices <- factor(div.ind$indices, 
                                 levels = c("Richesse", "Shannon", "Inv.simp"))

# Boxplot des indices de diversité par rôle
ggplot(div.ind ,
       aes(x=`Rôle`, y=`Valeur de l'indice de diversité`, fill=protocole))+
  geom_boxplot(alpha=0.7)+
  facet_wrap(vars(tech.tran.2, indices), scales = "free") +
  theme_bw() +
  scale_fill_manual(name = "Protocole",
                    labels = c("Transect", "Temps"),
                    breaks = c("TR", "TC"),
                    values = c("#bdbdbd", "#252525"))
```

## Courbe d accumulation par role

Courbe d’accumulation par rôle (C, N, C+N ou H, B, H+B)

```{r}
# on combine les jeux de communautés avec les informations sur les rôles
role.comm.data <- role.comm %>% 
  rownames_to_column(var="idSINPRegroupement_role") %>%
  left_join(role.data) 

# on sépare chaque jeu pour calculer l'accumulation de diversité avec specaccum par rôle pour chaque protocole plongée

## -- Temps - rôle C
TC.C <- role.comm.data %>% filter(role == "C" & protocole == "TC")%>%
  select(-role, -tech.tran.2, -protocole)
## -- Temps - rôle N
TC.N <- role.comm.data %>% filter(role == "N" & protocole == "TC")%>%
  select(-role, -tech.tran.2, -protocole)
## -- Temps - rôle C+N
TC.CN <- TC.forRole %>% filter(tech.tran.2 == "CC" & protocole == "TC") %>%
  select(-role, -tech.tran.2, -protocole, -idSINPRegroupement_role) %>%
  group_by(idSINPRegroupement_tran, nomCite) %>%
  summarize(ab.3=sum(ab.2)) %>%
  spread(nomCite, ab.3, fill=0)
## -- Temps - rôle H
TC.H <- role.comm.data %>% filter(role == "H" & protocole == "TC")%>%
  select(-role, -tech.tran.2, -protocole)
## -- Temps - rôle B
TC.B <- role.comm.data %>% filter(role == "B" & protocole == "TC")%>%
  select(-role, -tech.tran.2, -protocole)
## -- Temps - rôle H+B
TC.HB <- TC.forRole %>% filter(tech.tran.2 == "HB" & protocole == "TC") %>%
  select(-role, -tech.tran.2, -protocole, -idSINPRegroupement_role) %>%
  group_by(idSINPRegroupement_tran, nomCite) %>%
  summarize(ab.3=sum(ab.2)) %>%
  spread(nomCite, ab.3, fill=0)

## -- Transect - rôle C
TR.C <- role.comm.data %>% filter(role == "C" & protocole == "TR") %>%
  select(-role, -tech.tran.2, -protocole)
## -- Transect - rôle N
TR.N <- role.comm.data %>% filter(role == "N" & protocole == "TR")%>%
  select(-role, -tech.tran.2, -protocole)
## -- Transect - rôle C+N
TR.CN <- TR.forRole %>% filter(tech.tran.2 == "CC" & protocole == "TR") %>%
  select(-role, -tech.tran.2, -protocole, -idSINPRegroupement_role) %>%
  group_by(idSINPRegroupement_tran, nomCite) %>%
  summarize(ab.3=sum(ab.2)) %>%
  spread(nomCite, ab.3, fill=0)
## -- Transect - rôle H
TR.H <- role.comm.data %>% filter(role == "H" & protocole == "TR")%>%
  select(-role, -tech.tran.2, -protocole)
## -- Transect - rôle B
TR.B <- role.comm.data %>% filter(role == "B" & protocole == "TR")%>%
  select(-role, -tech.tran.2, -protocole)
## -- Transect - rôle H+B
TR.HB <- TR.forRole %>% filter(tech.tran.2 == "HB" & protocole == "TR") %>%
  select(-role, -tech.tran.2, -protocole, -idSINPRegroupement_role) %>%
  group_by(idSINPRegroupement_tran, nomCite) %>%
  summarize(ab.3=sum(ab.2)) %>%
  spread(nomCite, ab.3, fill=0)

# on créee la liste rassemblant toutes les matrices de communautés
df.for.spec.role <- list(TC.C=TC.C[,-1], TC.N=TC.N[,-1],
                    TC.CN=TC.CN[,-1],
                    TC.H=TC.H[,-1], TC.B=TC.B[,-1],
                    TC.HB=TC.HB[,-1],
                    TR.C=TR.C[,-1], TR.N=TR.N[,-1],
                    TR.CN=TR.CN[,-1],
                    TR.H=TR.H[,-1], TR.B=TR.B[,-1],
                    TR.HB=TR.HB[,-1])

make.spec <- function(df){
  #calc species accumulation curve for each role 
  curve = specaccum(df)
  # and make a df for ggplot
  curve.df <- data.frame(Sites=curve$sites, Richness=curve$richness,
                         SD=curve$sd)

  return(curve.df)
}

# on calcule specaccum pour chaque matrice de communauté
specc.all <- map_dfr(df.for.spec.role, make.spec, .id="var")
specc.all.2 <- specc.all %>%
  separate(var, c("prot", "role")) %>%
  mutate(tech.tran.2 = case_when(role == "C" | role == "N" | role == "CN"~ "Côte à Côte",
                                 role == "H" | role == "B" | role == "HB"~ "Haut-Bas")) %>%
  mutate(prot = gsub("TR", "Transect", prot),
         prot = gsub("TC", "Temps", prot))

specc.all.2$role <- factor(specc.all.2$role, 
                                 levels = c("CN", "C", "N",
                                            "HB", "H", "B"))
# on plot la curve d'accumulation
ggplot(data=specc.all.2, aes(x=Sites, y=Richness, color=role)) +
  geom_point(alpha=0.8) +
  geom_line(alpha=0.8) +
  geom_ribbon(data=specc.all.2 ,aes(x=Sites,
    ymin=(Richness-2*SD),ymax=(Richness+2*SD), fill=role),alpha=0.2, inherit.aes = FALSE) +
  #facet_grid(tech.tran.2 ~ prot, scales = "free")+
  facet_wrap(vars(prot, tech.tran.2), scales = "free")+
  theme_bw() +
  scale_fill_manual(name = "Rôle", 
                    labels = c("C+N", "Crypto", "Necto", 
                               "H+B", "Haut", "Bas"),
                    breaks = c("CN", "C", "N",
                               "HB", "H", "B") ,
                    values=c("#fdb462", "#756bb1", "#54278f",
                             "#a6611a", "#80cdc1", "#018571"))+
  scale_color_manual(name = "Rôle", 
                    labels = c("C+N", "Crypto", "Necto", 
                               "H+B", "Haut", "Bas"),
                    breaks = c("CN", "C", "N",
                               "HB", "H", "B") ,
                    values=c("#fdb462", "#756bb1", "#54278f",
                             "#a6611a", "#80cdc1", "#018571"))+
  xlab("Nombre de transect")+
  ylab("Richesse")
```

## Comparaison des rôles - espèces

Pourcentage des transects dans lesquels les **individus** pour chacune des espèces ont été observés par 1 des 2 rôles ou par les 2 rôles  


```{r}
unique(TC.forRole$role)
unique(TC.forRole$tech.tran.2)

TC.forRole2 <- TC.forRole %>%
  as.data.frame() %>%
  select(-idSINPRegroupement_role)  %>%
  spread(role, ab.2, fill=0) %>%
  mutate(comp.role = case_when(B == 0 & H > 0 ~ "H",
                               B > 0 & H == 0 ~ "B",
                               B > 0 & H > 0 ~ "H+B",
                               C == 0 & N > 0 ~ "N",
                               C > 0 & N == 0 ~ "C",
                               C > 0 & N > 0 ~ "C+N")) %>%
  group_by(nomCite, comp.role, tech.tran.2) %>%
  tally() %>%
  group_by(nomCite, tech.tran.2) %>%
  mutate(nb.tran = sum(n)) %>%
  mutate(perc=n * 100 / nb.tran) %>%
  mutate(prot="Temps") %>%
  ungroup()

unique(TR.forRole$role)
unique(TR.forRole$tech.tran.2)

TR.forRole2 <- TR.forRole %>%
  select(-idSINPRegroupement_role)  %>%
  spread(role, ab.2, fill=0) %>%
  mutate(comp.role = case_when(B == 0 & H > 0 ~ "H",
                               B > 0 & H == 0 ~ "B",
                               B > 0 & H > 0 ~ "H+B",
                               C == 0 & N > 0 ~ "N",
                               C > 0 & N == 0 ~ "C",
                               C > 0 & N > 0 ~ "C+N")) %>%
  group_by(nomCite, comp.role, tech.tran.2) %>%
  tally() %>%
  group_by(nomCite, tech.tran.2) %>%
  mutate(nb.tran = sum(n)) %>%
  mutate(perc=n * 100 / nb.tran) %>%
  mutate(prot="Transect") %>%
  ungroup()


prot.forRole <- bind_rows(TC.forRole2, TR.forRole2) %>%
  left_join(habitat) %>%
  unite(prot_tech, c(tech.tran.2, prot), remove=F) %>%
  unite(prot_col, c(pref_habitat_PT.v3, prot), remove=F) %>%
  filter(nb.tran > 10) 

prot.forRole$comp.role <- factor(prot.forRole$comp.role, 
                                 levels = c("H", "B", "H+B", 
                                            "C", "N","C+N"))

bar_labs.role <- prot.forRole %>% distinct(nb.tran, nomCite, prot_tech, prot)

ggplot(prot.forRole %>% filter(tech.tran.2=="CC"), 
       aes(x=fct_reorder(nomCite, nb.tran), y=perc, fill=comp.role))+
  geom_bar(stat="identity", alpha=0.8) +
  coord_flip() +
  #facet_wrap(vars(prot_col), scales = "free") +
  facet_grid(pref_habitat_PT.v3 ~ prot, scales = "free") +
  #geom_text(data = bar_labs.role %>% filter(tech.tran.2=="CC"), 
  #          aes(x=fct_reorder(nomCite, nb.tran), y=100, 
  #              label=nb.tran, group=prot_tech), 
  #          inherit.aes = FALSE)+
  scale_fill_manual(name = "Rôle", 
                    labels = c("C+N", "Crypto", "Necto"),
                    breaks = c("C+N", "C", "N") ,
                    values=c("#fdb462", "#756bb1", "#54278f"))+
  theme_bw() +
  xlab("")+ylab("") +
  ggtitle("Cote à cote - taxons présents dans plus de 10 transects du circalittoral")

ggplot(prot.forRole %>% filter(tech.tran.2=="HB"), 
       aes(x=fct_reorder(nomCite, nb.tran), y=perc, fill=comp.role))+
  geom_bar(stat="identity", alpha=0.8) +
  coord_flip() +
  #facet_wrap(vars(prot_col), scales = "free") +
  facet_grid(pref_habitat_PT.v3 ~ prot, scales = "free") +
  #geom_text(data = bar_labs.role %>% filter(tech.tran.2=="CC"), 
  #          aes(x=fct_reorder(nomCite, nb.tran), y=100, 
  #              label=nb.tran, group=prot_tech), 
  #          inherit.aes = FALSE)+
  scale_fill_manual(name = "Rôle", 
                    labels = c("H+B", "Haut", "Bas"),
                    breaks = c("H+B", "H", "B") ,
                    values=c("#a6611a", "#80cdc1", "#018571"))+
  theme_bw() +
  xlab("")+ylab("") +
  ggtitle("Haut Bas - taxons présents dans plus de 10 transects de l'infralittoral")

```

## Comparaison des rôles - classe de taille par espèce 

! pas fini

Pourcentage des transects dans lesquels les  **classes de taille des individus** pour chacune des espèces ont été observés par 1 des 2 rôles ou par les 2 rôles  

P <-- [TL < =TLmax/3] ;
M <-- [TLMax/3 < TL <= 2*TLMax/3] ;
G <-- [TL > 2*TLMax/3]


```{r, eval=FALSE}
# --- Transect 
unique(TR$role) # tous les transects ont des rôles

# on vire les roles avec no species
TR.nosp <- TR %>%  filter(nomCite!="No_species") 

# et du coup on vire les transects avec un seul rôle
TR.single <- TR.nosp %>%
  distinct(idSINPRegroupement_tran, idSINPRegroupement_role) %>%
  group_by(idSINPRegroupement_tran) %>%
  tally() %>%
  filter(n<2) %>%
  pull(idSINPRegroupement_tran)

TR.forRole.size.tmp <- TR.nosp %>% 
  filter(!idSINPRegroupement_tran %in% TR.single) %>%
  distinct(nomCite, taille, abondance,
           role, idSINPRegroupement_role,
           idSINPRegroupement_tran, techniqueEchantillonnage_tran) %>%
  mutate(tech.tran.2 = techniqueEchantillonnage_tran) %>%
  select(-techniqueEchantillonnage_tran) 

max.length.taxa.uvc <- taxa.uvc %>%
  left_join(traits.bdd2) %>% 
  select(nomCite, ScientificName_accepted, Max_length) %>%
  mutate(Max_length.2 = Max_length) %>%
  mutate(Max_length.2 = gsub(",", "\\.", Max_length.2),
         Max_length.2 = gsub("#N/A", NA, Max_length.2)) %>%
  mutate(Max_length.2 = as.numeric(Max_length.2)) %>%
  select(-Max_length) %>%
  rename(Max_length = Max_length.2)

TR.forRole.size <- TR.forRole.size.tmp %>%
  left_join(max.length.taxa.uvc) %>%
  # make class size based on max length 
  #mutate(class.size = case_when(taille <= Max_length/3 ~ "P",
  #                              taille > Max_length/3 & taille <= 2*Max_length/3 ~ "M",
  #                              taille > 2*Max_length/3 ~ "G")) %>%
  # make class size to match the one of TC : unique(TC$classe_taille)
  mutate(class.size = case_when(between(taille, 1, 5) ~ "1-5cm",
                                between(taille, 6, 15) ~ "6-15cm",
                                between(taille, 16, 40) ~ "16-40cm",
                                taille > 41 ~ "sup41cm")) %>%
  unite(nomCite_size, c(nomCite, class.size), remove=F) %>%
  group_by(tech.tran.2, idSINPRegroupement_tran,
           idSINPRegroupement_role, role, nomCite, nomCite_size) %>%
  summarize(ab.2=sum(abondance)) %>%
  ungroup()
    
TR.forRole.size %>%
  distinct(idSINPRegroupement_tran, idSINPRegroupement_role,
           role, tech.tran.2) %>%
  group_by(role, tech.tran.2) %>%
  tally() %>%
  spread(role, n, fill=0) %>% as.data.frame()

# --- Time count
unique(TC$role) # tous les transects n'ont pas un rôle

# on vire les roles avec no species
TC.nosp <- TC %>%  filter(nomCite!="No_species") 

TC.nosp %>%
  distinct(idSINPRegroupement_tran, idSINPRegroupement_role,
           role, techniqueEchantillonnage_tran) %>%
  group_by(role, techniqueEchantillonnage_tran) %>%
  tally() %>%
  spread(role, n, fill=0)

# on vire les roles avec no_species et avec NA et les techniques d'éch à problème
TC.tmp <-  TC.nosp %>% 
  # on supprime les cas où le rôle n'est pas rentré (que pour 2018 normalement)
  filter(!is.na(role)) %>%
  # on enlève les combinaisons de rôle qui n'ont pas au moins H et B ou C et N
  # ! vérifier avec Pierre 
  filter(techniqueEchantillonnage_tran!="NN" & 
         techniqueEchantillonnage_tran!="HBCBC" &
         #techniqueEchantillonnage_tran!="BNC" &
         #techniqueEchantillonnage_tran!="CNB" &
         #techniqueEchantillonnage_tran!="CNH" &
         techniqueEchantillonnage_tran!="HBCC") %>%
  filter(role =="C" | role =="N" | role == "H" | role == "B" ) %>%
  # on supprime les rôles non essentiels pour BNC, CNB et CNH
  mutate(to_rm = case_when(techniqueEchantillonnage_tran=="BNC" & role == "B" ~ "to.rm",
                            techniqueEchantillonnage_tran=="CNB" & role == "B" ~ "to.rm",
                            techniqueEchantillonnage_tran=="CNH" & role == "H" ~ "to.rm",
                           TRUE ~ "to.keep")) %>%
  filter(to_rm == "to.keep") %>%
  # on simplifie la tech d'échantillonnage
  mutate(tech.tran.2 = case_when(str_detect(techniqueEchantillonnage_tran, "HB|HHB") ~ "HB",
                                 str_detect(techniqueEchantillonnage_tran,
                                            "CC|CNN|NBCC|CN|CNBC|BNC") ~ "CC")) %>%
  # on sélectionne aléatoirement un plongeur sur 2 
  # qd il y a 3 plongeurs et que 2 ont fait le même rôle
  distinct(tech.tran.2,
           idSINPRegroupement_tran, role, idSINPRegroupement_role) %>%
  group_by(idSINPRegroupement_tran, role) %>%
  sample_n(1) %>%
  ungroup() %>%
  # on recreé le DATA.spset
  left_join(TC) %>%
  select(-techniqueEchantillonnage_tran)
  
# et du coup on vire les transects avec un seul rôle
TC.single <- TC.tmp %>%
  distinct(idSINPRegroupement_tran, idSINPRegroupement_role) %>%
  group_by(idSINPRegroupement_tran) %>%
  tally() %>%
  filter(n<2) %>%
  pull(idSINPRegroupement_tran)

TC.forRole.size <- TC.tmp %>% 
  filter(!idSINPRegroupement_tran %in% TC.single) %>%
  left_join(TC) %>%
  distinct(nomCite, abondance, classe_taille,
           role, idSINPRegroupement_role,
           idSINPRegroupement_tran, tech.tran.2) %>%
  as.data.frame() %>%
  unite(nomCite_size, c(nomCite, classe_taille), remove=F) %>%
  group_by(tech.tran.2, idSINPRegroupement_tran,
           idSINPRegroupement_role, role, nomCite, nomCite_size) %>%
  summarize(ab.2=sum(abondance)) %>%
  ungroup()


TC.forRole.size %>%
  distinct(idSINPRegroupement_tran, idSINPRegroupement_role,
           role, tech.tran.2) %>%
  group_by(role, tech.tran.2) %>%
  tally() %>%
  spread(role, n, fill=0)
```


```{r, eval=FALSE}
unique(TC.forRole.size$role)
unique(TC.forRole.size$tech.tran.2)

TC.forRole2.size <- TC.forRole.size %>%
  as.data.frame() %>%
  select(-idSINPRegroupement_role)  %>%
  spread(role, ab.2, fill=0) %>%
  mutate(comp.role = case_when(B == 0 & H > 0 ~ "H",
                               B > 0 & H == 0 ~ "B",
                               B > 0 & H > 0 ~ "H+B",
                               C == 0 & N > 0 ~ "N",
                               C > 0 & N == 0 ~ "C",
                               C > 0 & N > 0 ~ "C+N")) %>%
  group_by(nomCite, nomCite_size, comp.role, tech.tran.2) %>%
  tally() %>%
  group_by(nomCite, nomCite_size, tech.tran.2) %>%
  mutate(nb.tran = sum(n)) %>%
  mutate(perc=n * 100 / nb.tran) %>%
  mutate(prot="Temps") %>%
  ungroup()

unique(TR.forRole.size$role)
unique(TR.forRole.size$tech.tran.2)

TR.forRole2.size <- TR.forRole.size %>%
  mutate(role.2 = case_when(str_detect(role,"B") ~ "B",
                            str_detect(role,"H") ~ "H",
                            TRUE ~ role)) %>%
  as.data.frame() %>%
  select(-role, -idSINPRegroupement_role)  %>%
  spread(role.2, ab.2, fill=0) %>%
  mutate(comp.role = case_when(B == 0 & H > 0 ~ "H",
                               B > 0 & H == 0 ~ "B",
                               B > 0 & H > 0 ~ "H+B",
                               C1 == 0 & C4 > 0 ~ "N",
                               C1 > 0 & C4 == 0 ~ "C",
                               C1 > 0 & C4 > 0 ~ "C+N")) %>%
  group_by(nomCite, nomCite_size, comp.role, tech.tran.2) %>%
  tally() %>%
  group_by(nomCite, nomCite_size, tech.tran.2) %>%
  mutate(nb.tran = sum(n)) %>%
  mutate(perc=n * 100 / nb.tran) %>%
  mutate(prot="Transect") %>%
  ungroup()

crypto.trait <- traits.bdd2 %>% select(ScientificName_accepted, Cryptobenthic)

prot.forRole.size <- bind_rows(TC.forRole2.size, TR.forRole2.size) %>%
  left_join(habitat.bdd2) %>%
  left_join(crypto.trait) %>%
  unite(prot_tech, c(tech.tran.2, prot), remove=F) %>%
  unite(prot_col, c(posit.col, prot), remove=F) %>%
  unite(prot_crypto, c(Cryptobenthic, prot), remove=F) %>%
  filter(nb.tran > 10) 

prot.forRole.size$comp.role <- factor(prot.forRole.size$comp.role, 
                                 levels = c("H", "B", "H+B", 
                                            "C", "N","C+N"))

bar_labs.role.size <- prot.forRole.size %>% distinct(nb.tran, nomCite_size, prot_tech, prot)

ggplot(prot.forRole.size %>% filter(tech.tran.2=="CC"), 
       aes(x=nomCite_size, y=perc, fill=comp.role))+
  geom_bar(stat="identity") +
  coord_flip() +
  facet_grid(Cryptobenthic ~ prot, scales = "free") +
  scale_fill_manual(breaks = c("C+N", "C", "N") ,
                    values=c("#a6611a", "#80cdc1", "#018571"))+
  theme_bw() +
  xlab("")+ylab("") +
  ggtitle("Cote à cote - taxons par classe de taille présents dans plus de 10 transects du circalittoral")

ggplot(prot.forRole.size %>% filter(tech.tran.2=="HB"), 
       aes(x=nomCite_size, y=perc, fill=comp.role))+
  geom_bar(stat="identity") +
  coord_flip() +
  facet_grid(posit.col ~ prot, scales = "free") +
  scale_fill_manual(breaks = c("H+B", "H", "B") ,
                    values=c("#a6611a", "#80cdc1", "#018571"))+
  theme_bw() +
  xlab("")+ylab("") +
  ggtitle("Haut Bas - taxons  par classe de taille présents dans plus de 10 transects de l'infralittoral")
```

## Focus especes cryptobenthiques - rôle C1/C4

! pas fini

--> à creuser, voir aussi en fonction de la taille 

```{r}
TC.crypto <- TC.forRole %>%
  filter(tech.tran.2=="CC") %>%
  left_join(habitat) %>%
  filter(pref_habitat_PT.v3=="cryptobenthic")

ggplot(TC.crypto, aes(x=role, y=ab.2))+
  geom_boxplot()+
  #scale_y_continuous(trans='log10') +
  facet_wrap(vars(nomCite), scales="free")


TR.crypto <- TR.forRole %>%
  filter(tech.tran.2=="CC") %>%
  left_join(habitat) %>%
  filter(pref_habitat_PT.v3=="cryptobenthic")

ggplot(TR.crypto, aes(x=role, y=ab.2))+
  geom_boxplot()+
  #scale_y_continuous(trans='log10') +
  facet_wrap(vars(nomCite), scales="free")
```


## Diversité beta

## Decomposition div beta

```{r}
do.beta.decomp <- function(df, tech.ech, coef.chosen, quant.chosen){
  
  # On filtre sur le jeu en fonction des protocoles asso à chaque habitat et
  # on transforme en matrice de communauté
  
  df.com <- df %>%
    filter(tech.tran.2==tech.ech) %>%
    as.data.frame() %>%
    select(nomCite, ab.2, idSINPRegroupement_role) %>%
    spread(nomCite, ab.2, fill=0) %>%
    column_to_rownames(var="idSINPRegroupement_role") 
 
  # Decomposition de la diversite beta en fonction des familles et coeff de dissimilarité 
  df.beta.decomp <- adespatial::beta.div.comp(df.com, coef = coef.chosen, quant = quant.chosen) 
  
  # Conversion de la matrice triangulaire en long-format data frame. 
  df.repl <- as.matrix(df.beta.decomp$repl) # remplacement
  df.nest <- as.matrix(df.beta.decomp$rich) # nestedness
  df.diss <- as.matrix(df.beta.decomp$D) # dissimilarity matrix

  df.repl.resh <- reshape2::melt(df.repl)[reshape2::melt(upper.tri(df.repl))$value,]
  df.nest.resh <- reshape2::melt(df.nest)[reshape2::melt(upper.tri(df.nest))$value,]
  df.diss.resh <- reshape2::melt(df.diss)[reshape2::melt(upper.tri(df.diss))$value,]

  
  # Filter on value between roles of the same transect
  id.tran.tmp <- df %>%
    filter(tech.tran.2==tech.ech) %>%
    as.data.frame() %>%
    select(idSINPRegroupement_tran, idSINPRegroupement_role) %>%
    distinct() 
  
  df.repl.resh.OK <- df.repl.resh %>%
    rename(idSINPRegroupement_role=Var1) %>%
    left_join(id.tran.tmp) %>%
    rename(idSINPRegroupement_tran.Var1=idSINPRegroupement_tran) %>%
    rename(Var1=idSINPRegroupement_role) %>%
    rename(idSINPRegroupement_role=Var2) %>%
    left_join(id.tran.tmp) %>%
    rename(Var2=idSINPRegroupement_role) %>%
    rename(idSINPRegroupement_tran.Var2=idSINPRegroupement_tran) %>%
    filter(idSINPRegroupement_tran.Var1==idSINPRegroupement_tran.Var2) %>%
    rename(idSINPRegroupement_tran=idSINPRegroupement_tran.Var1) %>%
    select(-idSINPRegroupement_tran.Var2) %>%
    mutate(comp="replacement") %>%
    select(-Var1, -Var2)

  df.nest.resh.OK <- df.nest.resh %>%
    rename(idSINPRegroupement_role=Var1) %>%
    left_join(id.tran.tmp) %>%
    rename(idSINPRegroupement_tran.Var1=idSINPRegroupement_tran) %>%
    rename(Var1=idSINPRegroupement_role) %>%
    rename(idSINPRegroupement_role=Var2) %>%
    left_join(id.tran.tmp) %>%
    rename(Var2=idSINPRegroupement_role) %>%
    rename(idSINPRegroupement_tran.Var2=idSINPRegroupement_tran) %>%
    filter(idSINPRegroupement_tran.Var1==idSINPRegroupement_tran.Var2) %>%
    rename(idSINPRegroupement_tran=idSINPRegroupement_tran.Var1) %>%
    select(-idSINPRegroupement_tran.Var2) %>%
    mutate(comp="nestedness")%>%
    select(-Var1, -Var2)
  
  df.diss.resh.OK <- df.diss.resh %>%
    rename(idSINPRegroupement_role=Var1) %>%
    left_join(id.tran.tmp) %>%
    rename(idSINPRegroupement_tran.Var1=idSINPRegroupement_tran) %>%
    rename(Var1=idSINPRegroupement_role) %>%
    rename(idSINPRegroupement_role=Var2) %>%
    left_join(id.tran.tmp) %>%
    rename(Var2=idSINPRegroupement_role) %>%
    rename(idSINPRegroupement_tran.Var2=idSINPRegroupement_tran) %>%
    filter(idSINPRegroupement_tran.Var1==idSINPRegroupement_tran.Var2) %>%
    rename(idSINPRegroupement_tran=idSINPRegroupement_tran.Var1) %>%
    select(-idSINPRegroupement_tran.Var2) %>%
    mutate(comp="dissimilarity")%>%
    select(-Var1, -Var2)

  df.beta.decom <- bind_rows(df.repl.resh.OK, df.nest.resh.OK, df.diss.resh.OK)
  
  # on calcule la similarié (1-D)
  df.beta.decom.v2 <- df.beta.decom %>% 
    spread(comp, value) %>%
    mutate(similarity = 1-dissimilarity) %>%
    select(-dissimilarity) 

  return(df.beta.decom.v2)
  
}
```


### P/A

```{r}
# Transect - HB - PA
TR.HB.decom.bs.PA <- do.beta.decomp(df=TR.forRole, 
               tech.ech="HB", 
               coef.chosen="BS", 
               quant.chosen=FALSE)# FALSE --> sur P/A

TR.HB.decom.bs.PA.long <- TR.HB.decom.bs.PA %>%
  gather(comp, value, -idSINPRegroupement_tran)

# Temps - HB - PA
TC.HB.decom.bs.PA <- do.beta.decomp(df=TC.forRole, 
               tech.ech="HB", 
               coef.chosen="BS", 
               quant.chosen=FALSE)

TC.HB.decom.bs.PA.long <- TC.HB.decom.bs.PA %>%
  gather(comp, value, -idSINPRegroupement_tran)


# Transect - CC - pa
TR.CC.decom.bs.PA <- do.beta.decomp(df=TR.forRole, 
               tech.ech="CC", 
               coef.chosen="BS", 
               quant.chosen=FALSE)


TR.CC.decom.bs.PA.long <- TR.CC.decom.bs.PA %>%
  gather(comp, value, -idSINPRegroupement_tran)

# Temps - CC - PA
TC.CC.decom.bs.PA <- do.beta.decomp(df=TC.forRole, 
               tech.ech="CC", 
               coef.chosen="BS", 
               quant.chosen=FALSE)

TC.CC.decom.bs.PA.long <- TC.CC.decom.bs.PA %>%
  gather(comp, value, -idSINPRegroupement_tran)

```


```{r}
               
box1 <- ggplot(TR.HB.decom.bs.PA.long, aes(x=comp, y=value))+
  geom_violin(trim=FALSE, fill="gray") +
  geom_boxplot(width=0.1)+
  ggtitle("Transect Haut Bas")+
  theme_bw()+
  xlab("")

box2 <- ggplot(TC.HB.decom.bs.PA.long, aes(x=comp, y=value))+
  geom_violin(trim=FALSE, fill="gray") +
  geom_boxplot(width=0.1)+
  ggtitle("Temps Haut Bas")+
  theme_bw()+
  xlab("")
  
box3 <- ggplot(TR.HB.decom.bs.PA.long, aes(x=comp, y=value))+
  geom_violin(trim=FALSE, fill="gray") +
  geom_boxplot(width=0.1)+
  ggtitle("Transect Cote à cote")+
  theme_bw()+
  xlab("")

box4 <- ggplot(TR.CC.decom.bs.PA.long, aes(x=comp, y=value))+
  geom_violin(trim=FALSE, fill="gray") +
  geom_boxplot(width=0.1)+
  ggtitle("Temps Cote à cote")+
  theme_bw()+
  xlab("")

box <- ggarrange(box1, box2, box3, box4, nrow=2, ncol=2)
annotate_figure(box,
               top = text_grob("Baselga decomposition of Sørensen dissimilarity coefficients - P/A", face = "bold", size = 10))
```


```{r}
par(mfrow = c(2, 2))
t1 <- triangle.plot(TR.HB.decom.bs.PA[,c(3,4,2)],
              show = FALSE, 
              labeltriangle = FALSE, 
              addmean = TRUE)

text(-0.7, 0.5,"Replacement", cex = 1.5)
text(0.7, 0.5, "Nestedness", cex = 1.5)
text(0, -0.6, "Sørensen similarity", cex = 1.5)
title("Transect Haut Bas", cex.main = 2)

t2 <- triangle.plot(TC.HB.decom.bs.PA[,c(3,4,2)],
              show = FALSE, 
              labeltriangle = FALSE, 
              addmean = TRUE)

text(-0.7, 0.5,"Replacement", cex = 1.5)
text(0.7, 0.5, "Nestedness", cex = 1.5)
text(0, -0.6, "Sørensen similarity", cex = 1.5)
title("Temps Haut Bas", cex.main = 2)

t3 <- triangle.plot(TR.CC.decom.bs.PA[,c(3,4,2)],
              show = FALSE, 
              labeltriangle = FALSE, 
              addmean = TRUE)

text(-0.8, 0.5,"Replacement", cex = 1.5)
text(0.8, 0.5, "Nestedness", cex = 1.5)
text(0, -0.6, "Sørensen similarity", cex = 1.5)
title("Transect Cote à cote", cex.main = 2)

t4 <- triangle.plot(TC.CC.decom.bs.PA[,c(3,4,2)],
              show = FALSE, 
              labeltriangle = FALSE, 
              addmean = TRUE)

text(-0.7, 0.5,"Replacement", cex = 1.5)
text(0.7, 0.5, "Nestedness", cex = 1.5)
text(0, -0.6, "Sørensen similarity", cex = 1.5)
title("Temps Cote à cote", cex.main = 2)

mtext("Baselga decomposition of Sørensen dissimilarity coefficients - P/A", side = 1, line = -44, outer = TRUE, cex=1.5)

#dev.off()
```


### Abondance

```{r}
# Transect - HB - AB
TR.HB.decom.bs.AB <- do.beta.decomp(df=TR.forRole, 
               tech.ech="HB", 
               coef.chosen="BS", 
               quant.chosen=TRUE)# TRUE --> sur abondance

TR.HB.decom.bs.AB.long <- TR.HB.decom.bs.AB %>%
  gather(comp, value, -idSINPRegroupement_tran)

# Temps - HB - AB
TC.HB.decom.bs.AB <- do.beta.decomp(df=TC.forRole, 
               tech.ech="HB", 
               coef.chosen="BS", 
               quant.chosen=TRUE)

TC.HB.decom.bs.AB.long <- TC.HB.decom.bs.AB %>%
  gather(comp, value, -idSINPRegroupement_tran)


# Transect - CC - AB
TR.CC.decom.bs.AB <- do.beta.decomp(df=TR.forRole, 
               tech.ech="CC", 
               coef.chosen="BS", 
               quant.chosen=TRUE)


TR.CC.decom.bs.AB.long <- TR.CC.decom.bs.AB %>%
  gather(comp, value, -idSINPRegroupement_tran)

# Temps - CC - AB
TC.CC.decom.bs.AB <- do.beta.decomp(df=TC.forRole, 
               tech.ech="CC", 
               coef.chosen="BS", 
               quant.chosen=TRUE)

TC.CC.decom.bs.AB.long <- TC.CC.decom.bs.AB %>%
  gather(comp, value, -idSINPRegroupement_tran)

```



```{r}
box1 <- ggplot(TR.HB.decom.bs.PA.long, aes(x=comp, y=value))+
  geom_violin(trim=FALSE, fill="gray") +
  geom_boxplot(width=0.1)+
  ggtitle("Transect Haut Bas")+
  theme_bw()+
  xlab("")

box2 <- ggplot(TC.HB.decom.bs.AB.long, aes(x=comp, y=value))+
  geom_violin(trim=FALSE, fill="gray") +
  geom_boxplot(width=0.1)+
  ggtitle("Temps Haut Bas")+
  theme_bw()+
  xlab("")
  
box3 <- ggplot(TR.HB.decom.bs.AB.long, aes(x=comp, y=value))+
  geom_violin(trim=FALSE, fill="gray") +
  geom_boxplot(width=0.1)+
  ggtitle("Transect Cote à cote")+
  theme_bw()+
  xlab("")

box4 <- ggplot(TR.CC.decom.bs.AB.long, aes(x=comp, y=value))+
  geom_violin(trim=FALSE, fill="gray") +
  geom_boxplot(width=0.1)+
  ggtitle("Temps Cote à cote")+
  theme_bw()+
  xlab("")

box <- ggarrange(box1, box2, box3, box4, nrow=2, ncol=2)
annotate_figure(box,
               top = text_grob("Baselga decomposition of Sørensen dissimilarity coefficients - Abundance", face = "bold", size = 10))
```


```{r}
par(mfrow = c(2, 2))
t1 <- triangle.plot(TR.HB.decom.bs.AB[,c(3,4,2)],
              show = FALSE, 
              labeltriangle = FALSE, 
              addmean = TRUE)

text(-0.7, 0.5,"Replacement", cex = 1.5)
text(0.7, 0.5, "Nestedness", cex = 1.5)
text(0, -0.6, "Sørensen similarity", cex = 1.5)
title("Transect Haut Bas", cex.main = 2)

t2 <- triangle.plot(TC.HB.decom.bs.AB[,c(3,4,2)],
              show = FALSE, 
              labeltriangle = FALSE, 
              addmean = TRUE)

text(-0.7, 0.5,"Replacement", cex = 1.5)
text(0.7, 0.5, "Nestedness", cex = 1.5)
text(0, -0.6, "Sørensen similarity", cex = 1.5)
title("Temps Haut Bas", cex.main = 2)

t3 <- triangle.plot(TR.CC.decom.bs.AB[,c(3,4,2)],
              show = FALSE, 
              labeltriangle = FALSE, 
              addmean = TRUE)

text(-0.8, 0.5,"Replacement", cex = 1.5)
text(0.8, 0.5, "Nestedness", cex = 1.5)
text(0, -0.6, "Sørensen similarity", cex = 1.5)
title("Transect Cote à cote", cex.main = 2)

t4 <- triangle.plot(TC.CC.decom.bs.AB[,c(3,4,2)],
              show = FALSE, 
              labeltriangle = FALSE, 
              addmean = TRUE)

text(-0.7, 0.5,"Replacement", cex = 1.5)
text(0.7, 0.5, "Nestedness", cex = 1.5)
text(0, -0.6, "Sørensen similarity", cex = 1.5)
title("Temps Cote à cote", cex.main = 2)

mtext("Baselga decomposition of Sørensen dissimilarity coefficients - Abundance", side = 1, line = -44, outer = TRUE, cex=1.5)

#dev.off()
```


# Section - Longueur de transect
## Courbe d'accumulation

  + En sélectionnant aléatoirement une des 3 sections de 10mètres, l'un des duo de sections pour avoir 20m et le trio de section pour 30mètres
  
```{r}
TR.10m.alea <- TR.sec %>% 
  select(nomCite, abondance.sec.norm,
         idSINPRegroupement_tran, no_section) %>%
  # randomly select one section only
  group_by(idSINPRegroupement_tran) %>%
  sample_n(1) %>%
  unite(id_tran_sec, c(idSINPRegroupement_tran, no_section)) %>%
  spread(nomCite, abondance.sec.norm, fill=0) %>%
  select(-No_species)
  
TR.20m.alea <- TR.sec %>% 
  select(nomCite, abondance.sec.norm,
         idSINPRegroupement_tran, no_section) %>%
  # randomly select two sections only
  group_by(idSINPRegroupement_tran) %>%
  sample_n(2) %>%
  group_by(nomCite,
         idSINPRegroupement_tran) %>%
  summarize(sum.ab = sum(abondance.sec.norm)) %>%
  spread(nomCite, sum.ab, fill=0) %>%
  select(-No_species)

TR.30m.alea <- TR.sec %>% 
  group_by(nomCite,
         idSINPRegroupement_tran) %>%
  summarize(sum.ab = sum(abondance.sec.norm)) %>%
  spread(nomCite, sum.ab, fill=0) %>%
  select(-No_species)
  

df.for.spec.sec.alea <- list(TR.10m=TR.10m.alea[,-1],
                             TR.20m.2=TR.20m.alea[,-1],
                             TR.30m=TR.30m.alea[,-1])

specc.all.sec <- map_dfr(df.for.spec.sec.alea, make.spec, .id="var")

ggplot(data=specc.all.sec, aes(x=Sites, y=Richness, color=var)) +
  geom_point(alpha=0.8) +
  geom_line(alpha=0.8) +
  geom_ribbon(data=specc.all.sec, aes(x=Sites,
    ymin=(Richness-2*SD),ymax=(Richness+2*SD), fill=var),alpha=0.2, inherit.aes = FALSE) +
  theme_bw() +
  scale_fill_manual(name = "Longueur du tronçon", 
                    labels = c("10m", "20m", "30m"),
                    breaks = c("TR.10m", "TR.20m.2", "TR.30m") ,
                    values=c("#8dd3c7", "#b3de69", "#bebada"))+
  scale_color_manual(name = "Longueur du tronçon", 
                    labels = c("10m", "20m", "30m"),
                    breaks = c("TR.10m", "TR.20m.2", "TR.30m") ,
                    values=c("#8dd3c7", "#b3de69", "#bebada"))+
  xlab("Nombre d'unité d'échantillonnage")+
  ylab("Richesse")+
  theme(legend.position = "bottom")

```

+ Par zone et année

Ex. de Mer d'Iroise et Tregor

```{r}
acc.year.area <- function(year.chosen, area.chosen){
  
  TR.sec.filtered <- TR.sec %>%
    filter(year == year.chosen & area == area.chosen) 
  
  TR.10m.alea <- TR.sec.filtered %>% 
    select(nomCite, abondance.sec.norm,
         idSINPRegroupement_tran, no_section) %>%
    # randomly select one section only
    group_by(idSINPRegroupement_tran) %>%
    sample_n(1) %>%
    unite(id_tran_sec, c(idSINPRegroupement_tran, no_section)) %>%
    spread(nomCite, abondance.sec.norm, fill=0) %>%
    select(-No_species)
  
  TR.20m.alea <- TR.sec.filtered %>% 
    select(nomCite, abondance.sec.norm,
         idSINPRegroupement_tran, no_section) %>%
    # randomly select two sections only
    group_by(idSINPRegroupement_tran) %>%
    sample_n(2) %>%
    group_by(nomCite,
         idSINPRegroupement_tran) %>%
    summarize(sum.ab = sum(abondance.sec.norm)) %>%
    spread(nomCite, sum.ab, fill=0) %>%
    select(-No_species)

  TR.30m.alea <- TR.sec.filtered %>% 
    group_by(nomCite,
         idSINPRegroupement_tran) %>%
    summarize(sum.ab = sum(abondance.sec.norm)) %>%
    spread(nomCite, sum.ab, fill=0) %>%
    select(-No_species)
  

  df.for.spec.sec.alea <- list(TR.10m=TR.10m.alea[,-1],
                             TR.20m.2=TR.20m.alea[,-1],
                             TR.30m=TR.30m.alea[,-1])

  specc.sec <- map_dfr(df.for.spec.sec.alea, make.spec, .id="var")

return(specc.sec)
}

# Tregor - 2019 et 2020
specc.role.TRE.2019 <- acc.year.area(year.chosen = "2019", area.chosen = "Tregor")

ggplot(data=specc.role.TRE.2019, aes(x=Sites, y=Richness, color=var)) +
  geom_point(alpha=0.8) +
  geom_line(alpha=0.8) +
  geom_ribbon(data=specc.role.TRE.2019 ,aes(x=Sites,
    ymin=(Richness-2*SD),ymax=(Richness+2*SD), fill=var),alpha=0.2, inherit.aes = FALSE) +
  theme_bw() +
  scale_fill_manual(name = "Longueur du tronçon", 
                    labels = c("10m", "20m", "30m"),
                    breaks = c("TR.10m", "TR.20m.2", "TR.30m") ,
                    values=c("#8dd3c7", "#b3de69", "#bebada"))+
  scale_color_manual(name = "Longueur du tronçon", 
                    labels = c("10m", "20m", "30m"),
                    breaks = c("TR.10m", "TR.20m.2", "TR.30m") ,
                    values=c("#8dd3c7", "#b3de69", "#bebada"))+
  xlab("Nombre d'unité d'échantillonnage")+
  ylab("Richesse")+
  theme(legend.position = "bottom")+
  ggtitle("Tregor 2019")

specc.role.TRE.2020 <- acc.year.area(year.chosen = "2020", area.chosen = "Tregor")

ggplot(data=specc.role.TRE.2020, aes(x=Sites, y=Richness, color=var)) +
  geom_point(alpha=0.8) +
  geom_line(alpha=0.8) +
  geom_ribbon(data=specc.role.TRE.2020 ,aes(x=Sites,
    ymin=(Richness-2*SD),ymax=(Richness+2*SD), fill=var),alpha=0.2, inherit.aes = FALSE) +
  theme_bw() +
  scale_fill_manual(name = "Longueur du tronçon", 
                    labels = c("10m", "20m", "30m"),
                    breaks = c("TR.10m", "TR.20m.2", "TR.30m") ,
                    values=c("#8dd3c7", "#b3de69", "#bebada"))+
  scale_color_manual(name = "Longueur du tronçon", 
                    labels = c("10m", "20m", "30m"),
                    breaks = c("TR.10m", "TR.20m.2", "TR.30m") ,
                    values=c("#8dd3c7", "#b3de69", "#bebada"))+
  xlab("Nombre d'unité d'échantillonnage")+
  ylab("Richesse")+
  theme(legend.position = "bottom")+
  ggtitle("Tregor 2020")

# Mer d'Iroise 2019 et 2020
specc.role.IROI.2019 <- acc.year.area(year.chosen = "2019", area.chosen = "Mer d Iroise")

ggplot(data=specc.role.IROI.2019, aes(x=Sites, y=Richness, color=var)) +
  geom_point(alpha=0.8) +
  geom_line(alpha=0.8) +
  geom_ribbon(data=specc.role.IROI.2019 ,aes(x=Sites,
    ymin=(Richness-2*SD),ymax=(Richness+2*SD), fill=var),alpha=0.2, inherit.aes = FALSE) +
  theme_bw() +
  scale_fill_manual(name = "Longueur du tronçon", 
                    labels = c("10m", "20m", "30m"),
                    breaks = c("TR.10m", "TR.20m.2", "TR.30m") ,
                    values=c("#8dd3c7", "#b3de69", "#bebada"))+
  scale_color_manual(name = "Longueur du tronçon", 
                    labels = c("10m", "20m", "30m"),
                    breaks = c("TR.10m", "TR.20m.2", "TR.30m") ,
                    values=c("#8dd3c7", "#b3de69", "#bebada"))+
  xlab("Nombre d'unité d'échantillonnage")+
  ylab("Richesse")+
  theme(legend.position = "bottom")+
  ggtitle("Mer d'Iroise 2019")

specc.role.IROI.2020 <- acc.year.area(year.chosen = "2020", area.chosen = "Mer d Iroise")

ggplot(data=specc.role.IROI.2020, aes(x=Sites, y=Richness, color=var)) +
  geom_point(alpha=0.8) +
  geom_line(alpha=0.8) +
  geom_ribbon(data=specc.role.IROI.2020 ,aes(x=Sites,
    ymin=(Richness-2*SD),ymax=(Richness+2*SD), fill=var),alpha=0.2, inherit.aes = FALSE) +
  theme_bw() +
  scale_fill_manual(name = "Longueur du tronçon", 
                    labels = c("10m", "20m", "30m"),
                    breaks = c("TR.10m", "TR.20m.2", "TR.30m") ,
                    values=c("#8dd3c7", "#b3de69", "#bebada"))+
  scale_color_manual(name = "Longueur du tronçon", 
                    labels = c("10m", "20m", "30m"),
                    breaks = c("TR.10m", "TR.20m.2", "TR.30m") ,
                    values=c("#8dd3c7", "#b3de69", "#bebada"))+
  xlab("Nombre d'unité d'échantillonnage")+
  ylab("Richesse")+
  theme(legend.position = "bottom")+
  ggtitle("Mer d'Iroise 2020")
```

# NB

Améliorer la reproductibilité et lisibilité

Compléter les parties non annotées

Mettre la fonction pour faire les courbes d'accumulation dans un fichier R

# Sessioninfo

```{r}
sessionInfo()
```

